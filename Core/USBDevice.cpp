#include <QDebug>
#include <QThread>
#include "USBDevice.h"
#include "Logger.h"

const UCHAR USBDevice::CMD_START[] = {
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x71, 0x71, 0x71, 0xAA, 0x71, 0x71, 0x71,
    0xAA, 0x71, 0x71, 0x71, 0xAA, 0x71, 0x71, 0x71, 0xFF, 0x73, 0x73, 0x73, 0xFF, 0x74, 0x74, 0x74,
    0x00, 0x00, 0x75, 0x75, 0x00, 0x00, 0x76, 0x76, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x78, 0x78,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xAA, 0xAA,
};

const UCHAR USBDevice::CMD_FRAME_SIZE[] = {
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x71, 0x71, 0x71, 0xAA, 0x71, 0x71, 0x71,
    0xAA, 0x71, 0x71, 0x71, 0xAA, 0x71, 0x71, 0x71, 0xFF, 0x73, 0x73, 0x73, 0xFF, 0x74, 0x74, 0x74,
    0x0C, 0xA9, 0x75, 0x75, 0x07, 0x80, 0x76, 0x76, 0x01, 0x01, 0x75, 0x75, 0x01, 0x01, 0x76, 0x76,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA,
};

const UCHAR USBDevice::CMD_STOP[] = {
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x72, 0x72, 0x72, 0xAA, 0x72, 0x72, 0x72,
    0xAA, 0x72, 0x72, 0x72, 0xAA, 0x72, 0x72, 0x72, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xAA, 0xAA,
};

USBDevice::USBDevice(HWND hwnd)
    : m_hwnd(hwnd)
    , m_inEndpoint(nullptr)
    , m_outEndpoint(nullptr)
    , m_isTransferring(false)
    , m_frameSize(DEFAULT_TRANSFER_SIZE)
    , m_isConfigured(false)
{
    m_device = std::make_shared<CCyUSBDevice>(hwnd, CYUSBDRV_GUID, true);
}

USBDevice::~USBDevice()
{
    close();
}

bool USBDevice::isConnected() const
{
    return m_device && m_device->DeviceCount() > 0;
}

// 在设备初始化时添加重试机制
bool USBDevice::open()
{
    const int MAX_RETRIES = 3;
    const int RETRY_DELAY_MS = 500;

    LOG_DEBUG("Try open device");

    for (int attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        LOG_INFO(QString("Device open attempt %1 of %2").arg(attempt).arg(MAX_RETRIES));

        if (!m_device) {
            LOG_ERROR("Device not initialized");
            emitError("Device initialization error");
            return false;
        }

        if (m_device->DeviceCount() <= 0) {
            LOG_ERROR("No USB device found");
            emitError("No USB device found");
            return false;
        }

        if (!m_device->Open(0)) {
            LOG_ERROR(QString("Failed to open device (attempt %1)").arg(attempt));
            if (attempt < MAX_RETRIES) {
                QThread::msleep(RETRY_DELAY_MS);
                continue;
            }
            emitError("Failed to open device");
            return false;
        }

        if (!validateDevice()) {
            LOG_ERROR(QString("Device validation failed (attempt %1)").arg(attempt));
            close();
            if (attempt < MAX_RETRIES) {
                QThread::msleep(RETRY_DELAY_MS);
                continue;
            }
            return false;
        }

        if (!initEndpoints()) {
            LOG_ERROR(QString("Endpoint initialization failed (attempt %1)").arg(attempt));
            close();
            if (attempt < MAX_RETRIES) {
                QThread::msleep(RETRY_DELAY_MS);
                continue;
            }
            return false;
        }

        LOG_INFO("Device initialized successfully");
        emit statusChanged("ready");
        return true;
    }

    return false;
}

void USBDevice::close()
{
    if (m_isTransferring) {
        stopTransfer();
    }

    if (m_device) {
        m_device->Close();
    }

    m_inEndpoint = nullptr;
    m_outEndpoint = nullptr;

    emit statusChanged("disconnected");
}

bool USBDevice::reset()
{
    if (!m_device) return false;

    close();
    m_device->Reset();
    return open();
}

bool USBDevice::readData(PUCHAR buffer, LONG& length) {
    if (!m_device || !m_inEndpoint || !buffer) {
        LOG_ERROR("Device not properly initialized for reading data");
        return false;
    }

    m_inEndpoint->TimeOut = 1000;  // 1秒超时
    m_inEndpoint->Abort();
    return m_inEndpoint->XferData(buffer, length);
}

bool USBDevice::startTransfer()
{
    if (!m_device || !m_inEndpoint || !m_outEndpoint) {
        LOG_ERROR("Device not properly initialized");
        emitError("Device not properly initialized");
        return false;
    }

    LOG_INFO("Start hw data transfer...");

    if (m_isTransferring) {
        LOG_WARN("Transfer already in progress");
        return true;
    }

    // 发送开始命令
    if (!sendCommand(CMD_START, CMD_BUFFER_SIZE)) {
        LOG_ERROR("Failed to send start command");
        return false;
    }

    // 只有在特定条件下才设置传输标志
    if (m_channelMode != 0xfe && m_invertPn != 0xfe) {
        LOG_INFO("Transfering start OK");
        m_isTransferring = true;
        m_transferStartTime = std::chrono::steady_clock::now();
        emit statusChanged("transferring");
    }

    return true;
}

bool USBDevice::stopTransfer()
{
    if (!m_isTransferring) {
        LOG_DEBUG("No transfer in progress");
        return true;
    }

    LOG_INFO("Stopping hw data transfer...");

    // 发送停止命令
    if (!sendCommand(CMD_STOP, CMD_BUFFER_SIZE)) {
        LOG_ERROR("Failed to send stop command");
        // 继续执行停止流程，即使命令发送失败
    }

    // 计算传输统计信息
    auto duration = std::chrono::steady_clock::now() - m_transferStartTime;
    auto seconds = std::chrono::duration_cast<std::chrono::seconds>(duration).count();
    if (seconds > 0) {
        double rate = (m_totalTransferred / 1024.0 / 1024.0) / seconds;
        LOG_INFO(QString("Transfer complete - Total: %1 MB, Duration: %2s, Rate: %3 MB/s")
            .arg(m_totalTransferred / 1024.0 / 1024.0, 0, 'f', 2)
            .arg(seconds)
            .arg(rate, 0, 'f', 2));
    }

    m_isTransferring = false;
    emit statusChanged("ready");
    return true;
}

QString USBDevice::getDeviceInfo() const
{
    if (!m_device) return "No Device";

    return QString("VID:0x%1 PID:0x%2 %3")
        .arg(m_device->VendorID, 4, 16, QChar('0'))
        .arg(m_device->ProductID, 4, 16, QChar('0'))
        .arg(QString::fromLocal8Bit(m_device->FriendlyName));
}

bool USBDevice::isUSB3() const
{
    return m_device && m_device->bSuperSpeed;  // CCyUSBDevice 直接提供了这个属性
}

bool USBDevice::initEndpoints()
{
    LOG_DEBUG("Initializing endpoints...");

    m_device->SetAltIntfc(0);

    int endpointCount = m_device->EndPointCount();
    LOG_DEBUG(QString("Found %1 endpoints").arg(endpointCount));

    for (int i = 1; i < endpointCount; i++) {
        CCyUSBEndPoint* endpoint = m_device->EndPoints[i];
        if (endpoint->Attributes == 2) {  // Bulk endpoint
            if (endpoint->bIn) {
                m_inEndpoint = dynamic_cast<CCyBulkEndPoint*>(endpoint);
                LOG_DEBUG(QString("Found IN endpoint: 0x%1")
                    .arg(endpoint->Address, 2, 16, QChar('0')));
            }
            else {
                m_outEndpoint = dynamic_cast<CCyBulkEndPoint*>(endpoint);
                LOG_DEBUG(QString("Found OUT endpoint: 0x%1")
                    .arg(endpoint->Address, 2, 16, QChar('0')));
            }
        }
    }

    if (!m_inEndpoint || !m_outEndpoint) {
        LOG_ERROR("Required endpoints not found");
        emitError("Required endpoints not found");
        return false;
    }

    LOG_INFO("Endpoints initialized successfully");
    return true;
}

bool USBDevice::validateDevice()
{
    if (!m_device || !m_device->IsOpen()) {
        LOG_ERROR("Device not open");
        emitError("Device not open");
        return false;
    }

    // 记录完整的设备信息
    QString deviceInfo = QString("Device Info:\n")
        + QString("  VID: 0x%1\n").arg(m_device->VendorID, 4, 16, QChar('0'))
        + QString("  PID: 0x%1\n").arg(m_device->ProductID, 4, 16, QChar('0'))
        + QString("  USB Version: 0x%1\n").arg(m_device->BcdUSB, 4, 16, QChar('0'))
        + QString("  Name: %1\n").arg(m_device->FriendlyName)
        + QString("  Manufacturer: %1\n").arg(QString::fromWCharArray(m_device->Manufacturer))
        + QString("  Product: %1").arg(QString::fromWCharArray(m_device->Product));

    LOG_INFO(deviceInfo);

    // FX3设备速度检查 - 设备可能处于不同的速度模式
    QString speedMode;
    if (m_device->bSuperSpeed) {
        speedMode = "SuperSpeed (USB 3.0)";
    }
    else if (m_device->bHighSpeed) {
        speedMode = "HighSpeed (USB 2.0)";
    }
    else {
        speedMode = "FullSpeed/LowSpeed";
    }
    LOG_INFO(QString("USB Speed Mode: %1").arg(speedMode));

    // 检查是否为FX3设备
    if (m_device->VendorID == 0x04b4 && m_device->ProductID == 0x00f1) {
        LOG_INFO("Detected Cypress FX3 device");
        // FX3设备验证通过，不需要强制要求USB 3.0模式
    }
    else {
        LOG_ERROR("Not a Cypress FX3 device");
        emitError("Unsupported device type");
        return false;
    }

    // 验证端点配置
    int endpointCount = m_device->EndPointCount();
    LOG_INFO(QString("Found %1 endpoints").arg(endpointCount));

    if (endpointCount < 2) {
        LOG_ERROR("Invalid endpoint configuration");
        emitError("Device endpoint configuration error");
        return false;
    }

    // 检查设备状态
    if (m_device->UsbdStatus != 0) {
        char statusStr[256];
        m_device->UsbdStatusString(m_device->UsbdStatus, statusStr);
        LOG_ERROR(QString("Device status error: %1").arg(statusStr));
        emitError(QString("Device status error: %1").arg(statusStr));
        return false;
    }

    LOG_INFO("Device validation completed successfully");
    return true;
}

void USBDevice::emitError(const QString& error)
{
    qDebug() << "USB Error:" << error;
    emit deviceError(error);
    emit statusChanged("error");
}

bool USBDevice::sendCommand(const UCHAR* cmdTemplate, int length)
{
    if (!m_device || !m_outEndpoint) {
        LOG_ERROR("Device not properly initialized for sending command");
        return false;
    }

    // 分配命令缓冲区
    std::unique_ptr<UCHAR[]> cmdBuffer(new UCHAR[CMD_BUFFER_SIZE]);

    // 准备命令数据
    if (!prepareCommandBuffer(cmdBuffer.get(), cmdTemplate)) {
        LOG_WARN("Prepare commond failed");
        return false;
    }

    // 设置端点参数
    m_outEndpoint->TimeOut = 500;  // 按原代码设置超时为500ms
    m_outEndpoint->SetXferSize(CMD_BUFFER_SIZE);

    // 特殊情况处理
    if (m_channelMode == 0xfe && m_invertPn == 0xfe) {
        memset(cmdBuffer.get(), 0x00, CMD_BUFFER_SIZE);
        LOG_DEBUG("Special channel case");
    }

    // 中止输入端点当前传输
    if (m_inEndpoint) {
        m_inEndpoint->Abort();
        //LOG_DEBUG("Abort");
    }

    // 添加延时
    QThread::msleep(12);

    // 发送命令
    LONG actualLength = CMD_BUFFER_SIZE;
    bool success = m_outEndpoint->XferData(cmdBuffer.get(), actualLength);

    if (!success) {
        LOG_ERROR(QString("Command send failed, error: 0x%1")
            .arg(m_outEndpoint->LastError, 8, 16, QChar('0')));
        return false;
    }

    // 验证传输长度
    if (actualLength != CMD_BUFFER_SIZE) {
        LOG_ERROR(QString("Command length mismatch: sent %1, expected %2")
            .arg(actualLength).arg(CMD_BUFFER_SIZE));
        return false;
    }

    LOG_DEBUG(QString("Command sent successfully, length: %1").arg(actualLength));
    return true;
}

bool USBDevice::configureTransfer(ULONG frameSize)
{
    // 准备帧大小命令
    PUCHAR buf = new UCHAR[CMD_BUFFER_SIZE];
    memcpy_s(buf, CMD_BUFFER_SIZE, CMD_START, CMD_BUFFER_SIZE);

    if (!sendCommand(buf, CMD_BUFFER_SIZE)) {
        LOG_ERROR("Failed to configure frame size");
        return false;
    }

    m_frameSize = frameSize;
    m_isConfigured = true;
    return true;
}

bool USBDevice::prepareCommandBuffer(PUCHAR buffer, const UCHAR* cmdTemplate)
{
    if (!buffer || !cmdTemplate) {
        LOG_ERROR("Invalid buffer or template");
        return false;
    }

    // 复制基础命令模板
    memcpy_s(buffer, CMD_BUFFER_SIZE, cmdTemplate, CMD_BUFFER_SIZE);

    // 根据设备参数修改命令内容
    if (m_capType == 0x39) {
        buffer[80] = ((m_width * 3 + 1) & 0xff00) >> 8;
        buffer[81] = (m_width * 3 + 1) & 0xff;
    }
    else {
        buffer[80] = ((m_width * 3) & 0xff00) >> 8;
        buffer[81] = (m_width * 3) & 0xff;
    }

    buffer[84] = (m_height & 0xff00) >> 8;
    buffer[85] = m_height & 0xff;
    buffer[88] = m_lanSeq;
    buffer[89] = m_lanSeq;
    buffer[92] = m_capType;
    buffer[93] = m_capType;
    buffer[0x48] = m_channelMode | (m_channelMode << 4);
    buffer[0x4C] = m_invertPn;

    return true;
}

void USBDevice::updateTransferStats()
{
    auto now = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::seconds>(
        now - m_transferStartTime).count();

    if (duration > 0) {
        double totalMB = static_cast<double>(m_totalTransferred) / (1024 * 1024);
        double rateMBps = totalMB / duration;

        LOG_INFO(QString("Transfer complete - Total: %.2f MB, Duration: %ds, Rate: %.2f MB/s")
            .arg(totalMB)
            .arg(duration)
            .arg(rateMBps));
    }
}
